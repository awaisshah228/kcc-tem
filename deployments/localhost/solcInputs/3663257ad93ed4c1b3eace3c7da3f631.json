{
  "language": "Solidity",
  "sources": {
    "contracts/Admin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\r\n\r\ncontract Admin is Initializable {\r\n    address public admin;\r\n\r\n    // solhint-disable func-name-mixedcase\r\n    function _Admin_Init(address _admin) internal initializer {\r\n        admin = _admin;\r\n    }\r\n\r\n    function _onlyAdmin() private view {\r\n        require(msg.sender == admin, \"must be admin\");\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        _onlyAdmin();\r\n        _;\r\n    }\r\n\r\n    function changeAdmin(address _admin) public onlyAdmin {\r\n        admin = _admin;\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol": {
      "content": "pragma solidity >=0.4.24 <0.7.0;\n\n\n/**\n * @title Initializable\n *\n * @dev Helper contract to support initializer functions. To use it, replace\n * the constructor with a function that has the `initializer` modifier.\n * WARNING: Unlike constructors, initializer functions must be manually\n * invoked. This applies both to deploying an Initializable contract, as well\n * as extending an Initializable contract via inheritance.\n * WARNING: When used with inheritance, manual care must be taken to not invoke\n * a parent initializer twice, or ensure that all initializers are idempotent,\n * because this is not dealt with automatically as with constructors.\n */\ncontract Initializable {\n\n  /**\n   * @dev Indicates that the contract has been initialized.\n   */\n  bool private initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n   */\n  bool private initializing;\n\n  /**\n   * @dev Modifier to use in the initializer function of a contract.\n   */\n  modifier initializer() {\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\n\n    bool isTopLevelCall = !initializing;\n    if (isTopLevelCall) {\n      initializing = true;\n      initialized = true;\n    }\n\n    _;\n\n    if (isTopLevelCall) {\n      initializing = false;\n    }\n  }\n\n  /// @dev Returns true if and only if the function is running in the constructor\n  function isConstructor() private view returns (bool) {\n    // extcodesize checks the size of the code stored in an address, and\n    // address returns the current address. Since the code is still not\n    // deployed when running a constructor, any checks on its code size will\n    // yield zero, making it an effective way to detect if a contract is\n    // under construction or not.\n    address self = address(this);\n    uint256 cs;\n    assembly { cs := extcodesize(self) }\n    return cs == 0;\n  }\n\n  // Reserved storage space to allow for layout changes in the future.\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/Validators.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n// import \"./Params.sol\";\r\nimport \"./interfaces/IValidators.sol\";\r\nimport \"./interfaces/IPunish.sol\";\r\nimport \"./interfaces/IProposal.sol\";\r\nimport \"./interfaces/IReservePool.sol\";\r\nimport \"./library/SortedList.sol\";\r\nimport \"./library/SafeSend.sol\";\r\nimport \"./interfaces/IReservePool.sol\";\r\nimport \"./Admin.sol\";\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\nlibrary EnumerableSet {\r\n  \r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            \r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n  \r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n \r\nlibrary Address {\r\n   \r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n   \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract ReentrancyGuardUpgradeSafe is Initializable {\r\n    bool private _notEntered;\r\n\r\n\r\n    function __ReentrancyGuard_init() internal initializer {\r\n        __ReentrancyGuard_init_unchained();\r\n    }\r\n\r\n    function __ReentrancyGuard_init_unchained() internal initializer {\r\n\r\n\r\n        \r\n        _notEntered = true;\r\n\r\n    }\r\n\r\n    function _nonReentrant() private view {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n    }\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        _nonReentrant();\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\ncontract Params is Initializable {\r\n\r\n    // System contracts addresses \r\n    IValidators public  VALIDATOR_CONTRACT; // solhint-disable var-name-mixedcase\r\n    IPunish public  PUBLISH_CONTRACT;       // solhint-disable var-name-mixedcase\r\n    IProposal public  PROPOSAL_CONTRACT;    // solhint-disable var-name-mixedcase\r\n    IReservePool public RESERVEPOOL_CONTRACT; // solhint-disable var-name-mixedcase\r\n    uint256 public EPOCH; // solhint-disable var-name-mixedcase\r\n\r\n    // System params\r\n    uint16 public constant MAX_VALIDATORS = 29;\r\n\r\n    function _onlyMiner() private view {\r\n        require(msg.sender == block.coinbase, \"Miner only\");\r\n    }\r\n    \r\n\r\n    modifier onlyMiner() {\r\n        _onlyMiner();\r\n        _;\r\n    }\r\n    function _onlyPunishContract() private view {\r\n        require(msg.sender == address(PUBLISH_CONTRACT), \"Punish contract only\");\r\n    }\r\n\r\n    modifier onlyPunishContract() {\r\n        _onlyPunishContract();\r\n        _;\r\n    }\r\n    \r\n\r\n    modifier onlyBlockEpoch {\r\n        require(block.number % EPOCH == 0, \"Block epoch only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidatorsContract() {\r\n        require(msg.sender == address(VALIDATOR_CONTRACT), \"Validators contract only\");\r\n        _;\r\n\r\n    }\r\n\r\n    function _setAddressesAndEpoch(\r\n            address _validatorsContract,\r\n            address _punishContract,\r\n            address _proposalContract,\r\n            address _reservePool,\r\n            uint256 epoch\r\n    ) internal initializer{\r\n        VALIDATOR_CONTRACT = IValidators(payable(_validatorsContract));\r\n        PUBLISH_CONTRACT = IPunish(payable(_punishContract));\r\n        PROPOSAL_CONTRACT = IProposal(payable(_proposalContract));\r\n        RESERVEPOOL_CONTRACT = IReservePool(payable(_reservePool));\r\n        EPOCH = epoch;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Validators is\r\n    Params,\r\n    Admin,\r\n    ReentrancyGuardUpgradeSafe,\r\n    IValidators,\r\n    SafeSend\r\n{\r\n    using SafeMath for uint256;\r\n    //using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using SortedLinkedList for SortedLinkedList.List;\r\n    // apply to calculate fee distribution.\r\n    uint256 public constant FEE_TOTAL_SHARES = 10000;\r\n    uint256 public constant MAX_FEE_SHARES = 3000;\r\n    uint256 public constant VOTE_UNIT = 1e18;\r\n\r\n    event SetMinSelfBallots(uint256 min);\r\n    event SetMaxPunishmentBallots(uint256 max);\r\n    event SetRevokeLockingDuration(uint256 duration);\r\n    event SetFeeSetLockingDuration(uint256 duration);\r\n    event SetMarginLockingDuration(uint256 duration);\r\n\r\n    event NewValidatorAdded(\r\n        address indexed _validator,\r\n        address indexed _manager,\r\n        uint256 _feeShares,\r\n        bool _reused\r\n    );\r\n\r\n    event PunishValidator(\r\n        address indexed _validator,\r\n        uint256 indexed _blocknum,\r\n        uint256 _amount\r\n    );\r\n    event SetPoolStatus(address indexed validator, bool enabled);\r\n    event SetFeeShares(address indexed _validator, uint256 _feeShares);\r\n    event Vote(address indexed user, address indexed validator, uint256 amount);\r\n    event Revoke(\r\n        address indexed user,\r\n        address indexed validator,\r\n        uint256 amount,\r\n        uint256 lockingEndTime\r\n    );\r\n    event Withdraw(\r\n        address indexed user,\r\n        address indexed validator,\r\n        uint256 amount\r\n    );\r\n    event ClaimReward(\r\n        address indexed user,\r\n        address indexed validator,\r\n        uint256 pendingReward\r\n    );\r\n    event ClaimFeeReward(address indexed validator, uint256 amount);\r\n    event RewardTransfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event DepositMargin(\r\n        address indexed from,\r\n        address indexed validator,\r\n        uint256 amount\r\n    );\r\n    event RedeemMargin(\r\n        address indexed from,\r\n        address indexed validator,\r\n        uint256 amount\r\n    );\r\n    event ValidatorClaimReward(\r\n        address indexed validator,\r\n        uint256 pendingReward\r\n    );\r\n    event Receiveegc(address from, uint256 _amount);\r\n    // Total Ballots\r\n    uint256 public totalBallot;\r\n\r\n    // The duration to wait after revoking ballots and before withdrawing.\r\n    uint256 public revokeLockingDuration;\r\n\r\n    // The duration to wait after the last change of fee.\r\n    uint256 public feeSetLockingDuration;\r\n\r\n    // The duration to wait after revoking margins and before withdrawing.\r\n    uint256 public marginLockingDuration;\r\n\r\n    uint256 public maxPunishmentAmount;\r\n\r\n    // The minimum margin in ballots that a validator needs to deposit.\r\n    uint256 public minSelfBallots;\r\n\r\n    // The _sortedEnabledValidators contains all the enabled\r\n    // validators that are in descending order.\r\n    SortedLinkedList.List private _sortedEnabledValidators;\r\n\r\n    uint256 public rewardsLeft;\r\n\r\n    mapping(uint256 => mapping(Operation => bool)) public operationsDone;\r\n\r\n    mapping(address => PoolInfo) internal poolInfos;\r\n    mapping(address => Description) public candidateInfos;\r\n\r\n    mapping(bytes32 => bool) public usedProposals;\r\n\r\n    // Info of each user that votes.\r\n    mapping(address => mapping(address => UserInfo)) public userInfo;\r\n\r\n    // Info on each user's revoking ballots\r\n    mapping(address => mapping(address => RevokingInfo)) public revokingInfo;\r\n\r\n    // Mapping from the voter's address to\r\n    // the validators that the voter voted.\r\n    mapping(address => EnumerableSet.AddressSet) private _votingRecordIndexInfo;\r\n\r\n    // Mapping from the manager's address to\r\n    // the validators that the manager controls.\r\n    mapping(address => EnumerableSet.AddressSet) private managedValidatorInfo;\r\n\r\n    // The active validators in this epoch\r\n    address[] public activeValidators;\r\n\r\n    function initialize(\r\n        address[] calldata _validators,\r\n        address[] calldata _managers,\r\n        uint256[] calldata _feeShares,\r\n        address _admin,\r\n        address _validatorsContract,\r\n        address _punishContract,\r\n        address _proposalContract,\r\n        address _reservePool,\r\n        uint256 _epoch\r\n    ) external initializer {\r\n        require(\r\n            _validators.length == _feeShares.length &&\r\n                _validators.length == _managers.length &&\r\n                _validators.length > 0,\r\n            \"invalid validator \"\r\n        );\r\n\r\n        revokeLockingDuration = 3 days;\r\n        marginLockingDuration = 15 days;\r\n        feeSetLockingDuration = 1 days;\r\n        maxPunishmentAmount = 100 ether;\r\n        minSelfBallots = 0;\r\n\r\n        require(\r\n            address(this).balance >=\r\n                minSelfBallots.mul(_validators.length).mul(VOTE_UNIT),\r\n            \"no enough egc in validators contract\"\r\n        );\r\n\r\n        _Admin_Init(_admin);\r\n        _setAddressesAndEpoch(\r\n            _validatorsContract,\r\n            _punishContract,\r\n            _proposalContract,\r\n            _reservePool,\r\n            _epoch\r\n        );\r\n        __ReentrancyGuard_init();\r\n\r\n        for (uint256 i = 0; i < _validators.length; ++i) {\r\n            address val = _validators[i];\r\n            uint256 feeShares = _feeShares[i];\r\n            // update PoolInfo\r\n            PoolInfo storage pool = poolInfos[val];\r\n            pool.manager = _managers[i];\r\n            pool.validator = val;\r\n            pool.selfBallots = minSelfBallots;\r\n            pool.feeShares = feeShares;\r\n            pool.pendingFee = 0;\r\n            pool.feeDebt = 0;\r\n            pool.lastRewardBlock = block.number;\r\n            // solhint-disable not-rely-on-times\r\n            pool.feeSettLockingEndTime = block.timestamp.add(\r\n                feeSetLockingDuration\r\n            );\r\n            pool.suppliedBallots = minSelfBallots;\r\n            pool.accRewardPerShare = 0;\r\n            pool.voterNumber = 0;\r\n            pool.electedNumber = 0;\r\n            pool.enabled = true;\r\n\r\n            // Update Candidate Info\r\n            Description storage desc = candidateInfos[val];\r\n            desc.details = \"\";\r\n            desc.email = \"\";\r\n            desc.website = \"\";\r\n\r\n            _sortedEnabledValidators.improveRanking(poolInfos, val);\r\n            if (activeValidators.length < MAX_VALIDATORS) {\r\n                activeValidators.push(val);\r\n            }\r\n            totalBallot = totalBallot.add(pool.suppliedBallots);\r\n\r\n            emit NewValidatorAdded(val, _managers[i], feeShares, false);\r\n        }\r\n\r\n        for (uint256 i = 0; i < _validators.length; ++i) {\r\n            // @audit PVE001\r\n            EnumerableSet.add(\r\n                managedValidatorInfo[_managers[i]],\r\n                _validators[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    function setMinSelfBallots(uint256 _min) external onlyAdmin {\r\n        require(_min != minSelfBallots, \"Validators: No change detected.\");\r\n\r\n        minSelfBallots = _min;\r\n        emit SetMinSelfBallots(_min);\r\n    }\r\n\r\n    function setMaxPunishmentAmount(uint256 _max) external onlyAdmin {\r\n        require(_max != maxPunishmentAmount, \"Validators: No change detected.\");\r\n        maxPunishmentAmount = _max;\r\n\r\n        emit SetMaxPunishmentBallots(_max);\r\n    }\r\n\r\n    function setRevokeLockingDuration(uint256 _lockingDuration)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(\r\n            _lockingDuration != revokeLockingDuration,\r\n            \"Validators: No change detected.\"\r\n        );\r\n\r\n        revokeLockingDuration = _lockingDuration;\r\n        emit SetRevokeLockingDuration(_lockingDuration);\r\n    }\r\n\r\n    function setFeeSetLockingDuration(uint256 _lockingDuration)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(\r\n            _lockingDuration != feeSetLockingDuration,\r\n            \"Validators: No change detected.\"\r\n        );\r\n\r\n        feeSetLockingDuration = _lockingDuration;\r\n        emit SetFeeSetLockingDuration(_lockingDuration);\r\n    }\r\n\r\n    function setMarginLockingDuration(uint256 _lockingDuration)\r\n        external\r\n        onlyAdmin\r\n    {\r\n        require(\r\n            _lockingDuration != marginLockingDuration,\r\n            \"Validators: No change detected.\"\r\n        );\r\n\r\n        marginLockingDuration = _lockingDuration;\r\n\r\n        emit SetMarginLockingDuration(_lockingDuration);\r\n    }\r\n\r\n    function getValidatorsOfManager(address _manager)\r\n        external\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        EnumerableSet.AddressSet storage validators = managedValidatorInfo[\r\n            _manager\r\n        ];\r\n\r\n        uint256 validatorsLength = EnumerableSet.length(validators);\r\n        address[] memory validatorList = new address[](validatorsLength);\r\n\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < validatorsLength; i++) {\r\n            address val = address(EnumerableSet.at(validators, i));\r\n            validatorList[index] = val;\r\n            index = index.add(1);\r\n        }\r\n        return validatorList;\r\n    }\r\n\r\n    function addValidator(\r\n        address _validator,\r\n        address _manager,\r\n        bytes32 _proposalID,\r\n        uint256 _feeShares,\r\n        string memory description,\r\n        string memory website,\r\n        string memory email\r\n    ) public payable nonReentrant {\r\n        require(msg.value.mod(VOTE_UNIT) == 0, \"should be ether multiple.\");\r\n\r\n        require(!usedProposals[_proposalID], \"proposal cannot be reused\");\r\n        usedProposals[_proposalID] = true;\r\n\r\n        require(\r\n            PROPOSAL_CONTRACT.isProposalPassed(_validator, _proposalID),\r\n            \"proposal is not passed\"\r\n        );\r\n\r\n        require(\r\n            msg.sender == admin || msg.sender == _validator,\r\n            \"cant add valdator\"\r\n        );\r\n\r\n        require(_validator != address(0), \"Validators: ZERO_ADDRESS.\");\r\n        require(\r\n            _feeShares <= MAX_FEE_SHARES,\r\n            \"Validators: the fee shares should be in the range(0..3000).\"\r\n        );\r\n        require(\r\n            poolInfos[_validator].enabled == false,\r\n            \"already have an enabled pool\"\r\n        );\r\n\r\n        // how many votes does the validator's margin contribute\r\n        // to the pool\r\n        uint256 votes = msg.value.div(VOTE_UNIT);\r\n\r\n        if (poolInfos[_validator].validator == _validator) {\r\n            // reuse a previous pool\r\n            PoolInfo storage pool = poolInfos[_validator];\r\n\r\n            if (pool.selfBallots >= minSelfBallots) {\r\n                _validatorClaimReward(_validator);\r\n            }\r\n\r\n            // @audit PVE001\r\n            EnumerableSet.add(managedValidatorInfo[_manager], _validator);\r\n\r\n            pool.selfBallots = pool.selfBallots.add(votes);\r\n            pool.selfBallotsRewardsDebt = pool\r\n                .accRewardPerShare\r\n                .mul(pool.selfBallots)\r\n                .div(1e12);\r\n            pool.suppliedBallots = pool.suppliedBallots.add(votes);\r\n            pool.enabled = true;\r\n            pool.manager = _manager;\r\n            candidateInfos[_validator].website = website;\r\n            candidateInfos[_validator].email = email;\r\n            candidateInfos[_validator].details = description;\r\n\r\n            emit NewValidatorAdded(_validator, _manager, _feeShares, true);\r\n        } else {\r\n            poolInfos[_validator] = PoolInfo({\r\n                validator: _validator,\r\n                manager: _manager,\r\n                selfBallots: votes,\r\n                selfBallotsRewardsDebt: 0,\r\n                feeShares: _feeShares,\r\n                lastRewardBlock: block.number,\r\n                feeSettLockingEndTime: block.timestamp.add(\r\n                    feeSetLockingDuration\r\n                ), // solhint-disable not-rely-on-time\r\n                pendingFee: 0,\r\n                feeDebt: 0,\r\n                suppliedBallots: votes,\r\n                accRewardPerShare: 0,\r\n                voterNumber: 0,\r\n                electedNumber: 0,\r\n                enabled: true\r\n            });\r\n            candidateInfos[_validator] = Description({\r\n                website: website,\r\n                email: email,\r\n                details: description\r\n            });\r\n\r\n            emit NewValidatorAdded(_validator, _manager, _feeShares, false);\r\n        }\r\n\r\n        if (poolInfos[_validator].selfBallots >= minSelfBallots) {\r\n            _sortedEnabledValidators.improveRanking(poolInfos, _validator);\r\n        }\r\n\r\n        totalBallot = totalBallot.add(votes);\r\n    }\r\n\r\n    // Enable/disable the target pool\r\n    // Only admin can call this function.\r\n    function setPoolStatus(address _val, bool _enabled) public onlyAdmin {\r\n        _setPoolStatus(_val, _enabled);\r\n    }\r\n\r\n    function setFeeSharesOfValidator(uint256 _shares, address _val) public {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n        require(msg.sender == pool.manager, \"only manager can change it\");\r\n        require(pool.enabled, \"pool is not enabled\");\r\n        require(pool.validator != address(0), \"Pool does not exist\");\r\n        require(\r\n            _shares <= MAX_FEE_SHARES,\r\n            \"Validators: the fee shares should be in the range(0..3000).\"\r\n        );\r\n        require(\r\n            block.timestamp >= pool.feeSettLockingEndTime,\r\n            \"Validators: one time of change within 24 hours.\"\r\n        ); // solhint-disable not-rely-on-time\r\n\r\n        require(_shares != pool.feeShares, \"Validators: no change detected.\");\r\n\r\n        // total 10000(1e4) shares, how many shares validator itself occupies.\r\n        pool.feeShares = _shares;\r\n        //\r\n        pool.feeSettLockingEndTime = block.timestamp.add(feeSetLockingDuration); // solhint-disable not-rely-on-time\r\n\r\n        emit SetFeeShares(_val, _shares);\r\n    }\r\n\r\n    // Only the miner can call this function to distribute rewards to validators.\r\n    function distributeBlockReward()\r\n        external\r\n        payable\r\n        override\r\n        onlyMiner\r\n        nonReentrant\r\n    {\r\n        require(\r\n            !operationsDone[block.number][Operation.Distributed],\r\n            \"cannot be called more than once in a single block\"\r\n        );\r\n\r\n        operationsDone[block.number][Operation.Distributed] = true;\r\n\r\n        uint256 rewardsFromReservePool = RESERVEPOOL_CONTRACT\r\n            .withdrawBlockReward();\r\n        if (rewardsFromReservePool == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 numOfValidatorRewarded = 0;\r\n        // total amount available for distribution:\r\n        //   rewardLeft + rewardsFromReservePool\r\n        uint256 totalAvailable = rewardsLeft.add(rewardsFromReservePool);\r\n        uint256 totalDistributed = 0; // actually distributed\r\n\r\n        if (activeValidators.length > 0) {\r\n            // The total ballots of all active validators\r\n            uint256 _totalBallot = 0;\r\n            for (uint8 i = 0; i < activeValidators.length; i++) {\r\n                PoolInfo storage pool = poolInfos[activeValidators[i]];\r\n\r\n                // Distribute block rewards only to validators that have enough ballots and are enabled\r\n                if (pool.selfBallots >= minSelfBallots && pool.enabled) {\r\n                    _totalBallot = _totalBallot.add(\r\n                        poolInfos[activeValidators[i]].suppliedBallots\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (_totalBallot > 0) {\r\n                // roundoff error -\r\n                uint256 rewardsPerShare = totalAvailable.div(_totalBallot);\r\n\r\n                for (uint8 i = 0; i < activeValidators.length; i++) {\r\n                    PoolInfo storage pool = poolInfos[activeValidators[i]];\r\n\r\n                    if (pool.selfBallots < minSelfBallots || !pool.enabled) {\r\n                        continue;\r\n                    }\r\n\r\n                    uint256 poolRewards = rewardsPerShare.mul(\r\n                        pool.suppliedBallots\r\n                    );\r\n\r\n                    // roundoff error -\r\n                    // validator's commission fee\r\n                    uint256 feeReward = poolRewards.mul(pool.feeShares).div(\r\n                        FEE_TOTAL_SHARES\r\n                    );\r\n\r\n                    pool.pendingFee = pool.pendingFee.add(feeReward);\r\n\r\n                    // reward to be distributed to staked users\r\n                    uint256 votingReward = poolRewards.sub(feeReward);\r\n\r\n                    {\r\n                        pool.accRewardPerShare = pool.accRewardPerShare.add(\r\n                            votingReward.mul(1e12).div(pool.suppliedBallots) // roundoff error -\r\n                        );\r\n                    }\r\n\r\n                    // roundoff error -\r\n                    totalDistributed = totalDistributed.add(poolRewards);\r\n                    pool.lastRewardBlock = block.number;\r\n                    pool.electedNumber = pool.electedNumber.add(1);\r\n                    numOfValidatorRewarded++;\r\n                }\r\n            }\r\n        }\r\n\r\n        require(\r\n            totalAvailable >= totalDistributed,\r\n            \"Validators: totalAvailable is less than totalDistributed\"\r\n        );\r\n\r\n        //\r\n        rewardsLeft = totalAvailable.sub(totalDistributed);\r\n    }\r\n\r\n    function updateActiveValidatorSet(address[] calldata newSet)\r\n        external\r\n        override\r\n        onlyMiner\r\n        onlyBlockEpoch\r\n    {\r\n        operationsDone[block.number][Operation.UpdatedValidators] = true;\r\n\r\n        require(\r\n            newSet.length > 0 && newSet.length <= MAX_VALIDATORS,\r\n            \"invalid length of newSet array\"\r\n        );\r\n\r\n        activeValidators = newSet; // FIXME: gas cost ?\r\n    }\r\n\r\n    function getTopValidators()\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        uint256 nValidators = Math.min(\r\n            MAX_VALIDATORS,\r\n            _sortedEnabledValidators.length\r\n        );\r\n\r\n        if (nValidators == 0) {\r\n            return new address[](0);\r\n        }\r\n\r\n        address[] memory topValidators = new address[](nValidators);\r\n\r\n        // The first element\r\n        address currVal = _sortedEnabledValidators.head;\r\n        topValidators[0] = currVal;\r\n\r\n        // All other elements\r\n        uint256 nextIndex = 1;\r\n        while (nextIndex < nValidators) {\r\n            currVal = _sortedEnabledValidators.next[currVal];\r\n            topValidators[nextIndex] = currVal;\r\n            nextIndex++;\r\n        }\r\n\r\n        return topValidators;\r\n    }\r\n\r\n    // punish validator\r\n    function punish(address validator, bool remove)\r\n        external\r\n        override\r\n        onlyPunishContract\r\n    {\r\n        //\r\n        if (remove) {\r\n            _setPoolStatus(validator, false);\r\n        }\r\n\r\n        uint256 punishAmount = maxPunishmentAmount;\r\n        PoolInfo storage pool = poolInfos[validator];\r\n        uint256 selfBallotsReward = pool\r\n            .accRewardPerShare\r\n            .mul(pool.selfBallots)\r\n            .div(1e12)\r\n            .sub(pool.selfBallotsRewardsDebt);\r\n\r\n        uint256 amount = 0;\r\n        if (pool.pendingFee >= punishAmount) {\r\n            // from pendingFee\r\n            pool.pendingFee = pool.pendingFee.sub(punishAmount);\r\n            pool.feeDebt = pool.feeDebt.add(punishAmount);\r\n            amount = punishAmount;\r\n        } else {\r\n            // from pendingFee + selfBallotsReward\r\n            uint256 sub = punishAmount.sub(pool.pendingFee);\r\n            amount = amount.add(pool.pendingFee);\r\n            pool.feeDebt = pool.feeDebt.add(pool.pendingFee);\r\n            pool.pendingFee = 0;\r\n\r\n            if (selfBallotsReward >= sub) {\r\n                pool.selfBallotsRewardsDebt = pool.selfBallotsRewardsDebt.add(\r\n                    sub\r\n                );\r\n                amount = amount.add(sub);\r\n            } else {\r\n                pool.selfBallotsRewardsDebt = pool.selfBallotsRewardsDebt.add(\r\n                    selfBallotsReward\r\n                );\r\n                amount = amount.add(selfBallotsReward);\r\n            }\r\n        }\r\n\r\n        _sendValue(payable(address(RESERVEPOOL_CONTRACT)), amount);\r\n\r\n        emit PunishValidator(validator, block.number, amount);\r\n    }\r\n\r\n    // Deposit ballot - egc to the target validator for Reward allocation.\r\n    function vote(address _val) public payable nonReentrant {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n        require(\r\n            pool.selfBallots >= minSelfBallots,\r\n            \"Validators: must require minSelfBallots\"\r\n        );\r\n\r\n        require(\r\n            msg.sender != _val,\r\n            \"validator can only vote to himself by depositing margin.\"\r\n        );\r\n\r\n        uint256 ballotAmount = msg.value.div(VOTE_UNIT);\r\n\r\n        //\r\n        require(\r\n            msg.value > 0 && ballotAmount > 0,\r\n            \"Validators: votes must be integer multiple of 1 egc.\"\r\n        );\r\n\r\n        uint256 ballotValue = ballotAmount.mul(VOTE_UNIT);\r\n        uint256 diff = msg.value.sub(ballotValue);\r\n\r\n        _vote(msg.sender, _val, ballotAmount, pool);\r\n\r\n        // @audit N1 Remove unsued accessControl\r\n        if (diff > 0) {\r\n            _safeTransfer(diff, msg.sender);\r\n        }\r\n    }\r\n\r\n    // Withdraw vote tokens from target pool.\r\n    function revokeVote(address _val, uint256 _amount) external nonReentrant {\r\n        require(\r\n            msg.sender != _val,\r\n            \"validator can only vote to himself by depositing margin.\"\r\n        );\r\n        _revokeVote(msg.sender, _val, _amount);\r\n    }\r\n\r\n    function withdraw(address _val) external nonReentrant {\r\n        require(\r\n            msg.sender != _val,\r\n            \"validator can only vote to himself by depositing margin.\"\r\n        );\r\n        require(\r\n            isWithdrawable(msg.sender, _val),\r\n            \"Validators: no ballots to withdraw or ballots are still locking.\"\r\n        );\r\n\r\n        _withdraw(msg.sender, _val);\r\n    }\r\n\r\n    // claim reward tokens from target pool.\r\n    function claimReward(address _val) external nonReentrant {\r\n        return _claimReward(_val);\r\n    }\r\n\r\n    // Claim commission fee of a validator\r\n    // @param _val the address of the validator\r\n    function claimFeeReward(address _val) external nonReentrant {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n\r\n        require(pool.validator == _val, \"no such pool\");\r\n\r\n        require(\r\n            pool.manager == msg.sender,\r\n            \"Validators: only manager of the pool can claim fee rewards\"\r\n        );\r\n\r\n        require(\r\n            pool.pendingFee > 0,\r\n            \"Validators: no pending fee reward to claim.\"\r\n        );\r\n\r\n        uint256 feeReward = pool.pendingFee;\r\n        pool.pendingFee = 0; // reset to 0\r\n        pool.feeDebt = pool.feeDebt.add(feeReward);\r\n\r\n        //\r\n        _safeTransfer(feeReward, msg.sender);\r\n\r\n        //\r\n        emit ClaimFeeReward(pool.validator, feeReward);\r\n    }\r\n\r\n    //\r\n    function isPool(address _validator) external view returns (bool) {\r\n        return (poolInfos[_validator].validator != address(0));\r\n    }\r\n\r\n    // A user's pending rewards in a pool of a validator.\r\n    function pendingReward(address _val, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _calculatePendingReward(_val, _user);\r\n    }\r\n\r\n    // The voting summary of a user\r\n    function getUserVotingSummary(address _user)\r\n        external\r\n        view\r\n        returns (VotingData[] memory votingDataList)\r\n    {\r\n        EnumerableSet.AddressSet storage recordIndexes = _votingRecordIndexInfo[\r\n            _user\r\n        ];\r\n\r\n        uint256 recordIndexesLength = EnumerableSet.length(recordIndexes);\r\n        votingDataList = new VotingData[](recordIndexesLength);\r\n\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < recordIndexesLength; i++) {\r\n            address val = address(EnumerableSet.at(recordIndexes, i));\r\n\r\n            PoolInfo memory pool = poolInfos[val];\r\n            UserInfo memory user = userInfo[val][_user];\r\n            RevokingInfo memory revokingInfoItem = revokingInfo[_user][val];\r\n\r\n            uint256 pending = _calculatePendingReward(val, _user);\r\n            votingDataList[index] = VotingData({\r\n                validator: pool.validator,\r\n                validatorBallot: pool.suppliedBallots,\r\n                feeShares: pool.feeShares,\r\n                ballot: user.amount,\r\n                pendingReward: pending,\r\n                revokingBallot: revokingInfoItem.amount,\r\n                revokeLockingEndTime: revokingInfoItem.lockingEndTime\r\n            });\r\n            index = index.add(1);\r\n        }\r\n    }\r\n\r\n    //\r\n    function isWithdrawable(address _user, address _val)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        RevokingInfo memory revokingInfoItem = revokingInfo[_user][_val];\r\n        return (revokingInfoItem.amount > 0 &&\r\n            block.timestamp >= revokingInfoItem.lockingEndTime); // solhint-disable not-rely-on-time\r\n    }\r\n\r\n    function _calculatePendingReward(address _val, address _user)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo memory pool = poolInfos[_val];\r\n        UserInfo memory user = userInfo[_val][_user];\r\n\r\n        return\r\n            user.amount.mul(pool.accRewardPerShare).div(1e12).sub(\r\n                user.rewardDebt\r\n            );\r\n    }\r\n\r\n    function _vote(\r\n        address _user,\r\n        address _val,\r\n        uint256 _amount,\r\n        PoolInfo storage pool\r\n    ) internal {\r\n        UserInfo storage user = userInfo[_val][_user];\r\n\r\n        if (user.amount > 0) {\r\n            uint256 pending = _calculatePendingReward(_val, _user);\r\n            if (pending > 0) {\r\n                _safeTransfer(pending, msg.sender);\r\n                emit ClaimReward(_user, _val, pending);\r\n            }\r\n        } else {\r\n            pool.voterNumber = pool.voterNumber.add(1);\r\n\r\n            EnumerableSet.AddressSet\r\n                storage recordIndexes = _votingRecordIndexInfo[_user];\r\n            EnumerableSet.add(recordIndexes, _val);\r\n        }\r\n\r\n        user.amount = user.amount.add(_amount);\r\n\r\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\r\n\r\n        pool.suppliedBallots = pool.suppliedBallots.add(_amount);\r\n\r\n        totalBallot = totalBallot.add(_amount);\r\n\r\n        if (pool.selfBallots >= minSelfBallots && pool.enabled) {\r\n            _sortedEnabledValidators.improveRanking(poolInfos, pool.validator);\r\n        }\r\n        // emit event\r\n        emit Vote(_user, _val, _amount);\r\n    }\r\n\r\n    function _withdraw(address _user, address _val) internal {\r\n        RevokingInfo storage revokingInfoItem = revokingInfo[_user][_val];\r\n        UserInfo memory user = userInfo[_val][_user];\r\n\r\n        uint256 amount = revokingInfoItem.amount;\r\n\r\n        revokingInfoItem.amount = 0;\r\n\r\n        _safeTransfer(amount.mul(VOTE_UNIT), msg.sender);\r\n\r\n        if (user.amount == 0) {\r\n            EnumerableSet.AddressSet\r\n                storage recordIndexes = _votingRecordIndexInfo[_user];\r\n\r\n            EnumerableSet.remove(recordIndexes, _val);\r\n        }\r\n        emit Withdraw(_user, _val, amount);\r\n    }\r\n\r\n    // @param _amount is the number of ballots\r\n    function _revokeVote(\r\n        address _user,\r\n        address _val,\r\n        uint256 _amount\r\n    ) internal {\r\n        require(_amount > 0, \"the revoking amount must be greater than zero\");\r\n\r\n        PoolInfo storage pool = poolInfos[_val];\r\n        UserInfo storage user = userInfo[_val][_user];\r\n\r\n        uint256 availableAmount = user.amount;\r\n        require(\r\n            availableAmount >= _amount,\r\n            \"Validators: no enough ballots to revoke.\"\r\n        );\r\n\r\n        uint256 pending = _calculatePendingReward(_val, _user);\r\n\r\n        if (pending > 0) {\r\n            _safeTransfer(pending, msg.sender);\r\n            emit ClaimReward(_user, _val, pending);\r\n        }\r\n\r\n        if (isWithdrawable(_user, _val)) {\r\n            _withdraw(_user, _val);\r\n        }\r\n\r\n        pool.suppliedBallots = pool.suppliedBallots.sub(_amount);\r\n\r\n        user.amount = availableAmount.sub(_amount);\r\n\r\n        user.rewardDebt = user.amount.mul(pool.accRewardPerShare).div(1e12);\r\n\r\n        totalBallot = totalBallot.sub(_amount);\r\n\r\n        if (user.amount == 0) {\r\n            pool.voterNumber = pool.voterNumber.sub(1);\r\n        }\r\n\r\n        _updateRevokingInfo(_user, _val, _amount, revokeLockingDuration);\r\n\r\n        _sortedEnabledValidators.lowerRanking(poolInfos, _val);\r\n    }\r\n\r\n    function _safeTransfer(uint256 _amount, address to) internal {\r\n        uint256 totalSpendableReward = address(this).balance;\r\n        if (_amount > totalSpendableReward) {\r\n            _sendValue(payable(to), totalSpendableReward);\r\n            emit RewardTransfer(address(this), to, totalSpendableReward);\r\n        } else {\r\n            _sendValue(payable(to), _amount);\r\n            emit RewardTransfer(address(this), to, _amount);\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Receiveegc(msg.sender, msg.value);\r\n    }\r\n\r\n    function isActiveValidator(address val)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < activeValidators.length; ++i) {\r\n            if (activeValidators[i] == val) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getActiveValidators()\r\n        external\r\n        view\r\n        override\r\n        returns (address[] memory)\r\n    {\r\n        return activeValidators;\r\n    }\r\n\r\n    function depositMargin(address _val) external payable nonReentrant {\r\n        require(\r\n            msg.value > 0 && msg.value.mod(VOTE_UNIT) == 0,\r\n            \"Validators: votes must be integer multiple of 1 egc.\"\r\n        );\r\n        uint256 ballots = msg.value.div(VOTE_UNIT);\r\n\r\n        require(\r\n            msg.sender == poolInfos[_val].manager,\r\n            \"pool does not exist or msg.sender is not the manager of the pool\"\r\n        );\r\n        PoolInfo storage pool = poolInfos[_val];\r\n\r\n        if (pool.selfBallots > 0) {\r\n            _validatorClaimReward(_val);\r\n        }\r\n\r\n        pool.selfBallots = pool.selfBallots.add(ballots);\r\n        pool.selfBallotsRewardsDebt = pool\r\n            .accRewardPerShare\r\n            .mul(pool.selfBallots)\r\n            .div(1e12);\r\n        pool.suppliedBallots = pool.suppliedBallots.add(ballots);\r\n        totalBallot = totalBallot.add(ballots);\r\n\r\n        if (pool.selfBallots >= minSelfBallots && pool.enabled) {\r\n            _sortedEnabledValidators.improveRanking(poolInfos, _val);\r\n        }\r\n\r\n        emit DepositMargin(msg.sender, _val, msg.value);\r\n    }\r\n\r\n    function redeemMargin(address _val, uint256 _amount) external nonReentrant {\r\n        require(\r\n            _amount > 0,\r\n            \"Validators: redeem amount must be greater than 0\"\r\n        );\r\n        require(\r\n            msg.sender == poolInfos[_val].manager,\r\n            \"pool does not exist or msg.sender is not the manager of the pool\"\r\n        );\r\n\r\n        PoolInfo storage pool = poolInfos[_val];\r\n        require(_amount <= pool.selfBallots, \"Validators: invalid amount.\");\r\n\r\n        _validatorClaimReward(_val);\r\n\r\n        if (isWithdrawable(_val, _val)) {\r\n            _withdrawMargin(msg.sender); // => redeemMargin\r\n        }\r\n\r\n        uint256 ballot = pool.suppliedBallots;\r\n        pool.suppliedBallots = ballot.sub(_amount);\r\n        totalBallot = totalBallot.sub(_amount);\r\n        pool.selfBallots = pool.selfBallots.sub(_amount);\r\n        pool.selfBallotsRewardsDebt = pool\r\n            .accRewardPerShare\r\n            .mul(pool.selfBallots)\r\n            .div(1e12);\r\n\r\n        if (pool.selfBallots < minSelfBallots) {\r\n            _sortedEnabledValidators.removeRanking(_val);\r\n        } else {\r\n            _sortedEnabledValidators.lowerRanking(poolInfos, _val);\r\n        }\r\n\r\n        _updateRevokingInfo(_val, _val, _amount, marginLockingDuration);\r\n\r\n        emit RedeemMargin(msg.sender, _val, _amount);\r\n    }\r\n\r\n    function _claimReward(address _val) internal {\r\n        UserInfo storage user = userInfo[_val][msg.sender];\r\n\r\n        uint256 pending = _calculatePendingReward(_val, msg.sender);\r\n        require(pending > 0, \"Validators: no pending reward to claim.\");\r\n\r\n        user.rewardDebt = user\r\n            .amount\r\n            .mul(poolInfos[_val].accRewardPerShare)\r\n            .div(1e12);\r\n        _safeTransfer(pending, msg.sender);\r\n\r\n        emit ClaimReward(msg.sender, _val, pending);\r\n    }\r\n\r\n    function updateCandidateInfo(\r\n        address _validator,\r\n        string memory details,\r\n        string memory website,\r\n        string memory email\r\n    ) external onlyAdmin {\r\n        require(bytes(details).length <= 3000, \"description is too long\");\r\n        require(bytes(website).length <= 100, \"website is too long\");\r\n        require(bytes(email).length <= 50, \"email is too long\");\r\n\r\n        Description storage desc = candidateInfos[_validator];\r\n\r\n        if (\r\n            bytes(details).length >= 0 &&\r\n            keccak256(bytes(details)) != keccak256(bytes(desc.details))\r\n        ) {\r\n            desc.details = details;\r\n        }\r\n        if (\r\n            bytes(website).length >= 0 &&\r\n            keccak256(bytes(website)) != keccak256(bytes(desc.website))\r\n        ) {\r\n            desc.website = website;\r\n        }\r\n        if (\r\n            bytes(email).length >= 0 &&\r\n            keccak256(bytes(email)) != keccak256(bytes(desc.email))\r\n        ) {\r\n            desc.email = email;\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    function _calculateValidatorPendingReward(address _val)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo memory pool = poolInfos[_val];\r\n\r\n        return\r\n            // roundoff error -\r\n            pool.selfBallots.mul(pool.accRewardPerShare).div(1e12).sub(\r\n                pool.selfBallotsRewardsDebt\r\n            );\r\n    }\r\n\r\n    function _validatorClaimReward(address _val) internal {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n\r\n        //\r\n        uint256 pending = _calculateValidatorPendingReward(_val); // roundoff error -\r\n        if (pending > 0) {\r\n            // @audit PVE003\r\n            _safeTransfer(pending, pool.manager);\r\n        }\r\n        //\r\n        // roundoff error -\r\n        pool.selfBallotsRewardsDebt = pool\r\n            .selfBallots\r\n            .mul(pool.accRewardPerShare)\r\n            .div(1e12);\r\n        emit ValidatorClaimReward(_val, pending);\r\n    }\r\n\r\n    function _setPoolStatus(address _val, bool _enabled) internal {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n        if (pool.enabled != _enabled) {\r\n            pool.enabled = _enabled;\r\n\r\n            if (!_enabled) {\r\n                _sortedEnabledValidators.removeRanking(_val);\r\n            } else {\r\n                _sortedEnabledValidators.improveRanking(poolInfos, _val);\r\n            }\r\n        }\r\n        emit SetPoolStatus(_val, _enabled);\r\n    }\r\n\r\n    function _updateRevokingInfo(\r\n        address _user,\r\n        address _val,\r\n        uint256 _amount,\r\n        uint256 lockingDuration\r\n    ) internal {\r\n        RevokingInfo storage revokingInfoItem = revokingInfo[_user][_val];\r\n        //\r\n        revokingInfoItem.amount = revokingInfoItem.amount.add(_amount);\r\n        revokingInfoItem.lockingEndTime = block.timestamp.add(lockingDuration); // solhint-disable not-rely-on-time\r\n\r\n        // emit event\r\n        emit Revoke(\r\n            _user,\r\n            _val,\r\n            revokingInfoItem.amount,\r\n            revokingInfoItem.lockingEndTime\r\n        );\r\n    }\r\n\r\n    function withdrawMargin(address _val) external nonReentrant {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n        require(pool.validator == _val, \"no such pool\");\r\n        require(\r\n            pool.manager == msg.sender,\r\n            \"operation is only allowed by manager\"\r\n        );\r\n        if (isWithdrawable(_val, _val)) {\r\n            _withdrawMargin(_val);\r\n        }\r\n    }\r\n\r\n    function _withdrawMargin(address _val) internal {\r\n        RevokingInfo storage revokingInfoItem = revokingInfo[_val][_val];\r\n\r\n        uint256 amount = revokingInfoItem.amount;\r\n\r\n        revokingInfoItem.amount = 0;\r\n\r\n        _safeTransfer(amount.mul(VOTE_UNIT), msg.sender);\r\n    }\r\n\r\n    function claimSelfBallotsReward(address _val) external nonReentrant {\r\n        PoolInfo storage pool = poolInfos[_val];\r\n\r\n        require(pool.validator == _val, \"no such pool\");\r\n        require(\r\n            msg.sender == pool.manager,\r\n            \"only the pool manager can claim rewards\"\r\n        );\r\n\r\n        _validatorClaimReward(_val);\r\n    }\r\n\r\n    function getPoolSelfBallots(address val) external view returns (uint256) {\r\n        return poolInfos[val].selfBallots;\r\n    }\r\n\r\n    function getPoolSelfBallotsRewardsDebt(address val)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return poolInfos[val].selfBallotsRewardsDebt;\r\n    }\r\n\r\n    function getPoolfeeShares(address val) external view returns (uint256) {\r\n        return poolInfos[val].feeShares;\r\n    }\r\n\r\n    function getPoolpendingFee(address val) external view returns (uint256) {\r\n        return poolInfos[val].pendingFee;\r\n    }\r\n\r\n    function getPoolfeeDebt(address val) external view returns (uint256) {\r\n        return poolInfos[val].feeDebt;\r\n    }\r\n\r\n    function getPoollastRewardBlock(address val)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return poolInfos[val].lastRewardBlock;\r\n    }\r\n\r\n    function getPoolfeeSettLockingEndTime(address val)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return poolInfos[val].feeSettLockingEndTime;\r\n    }\r\n\r\n    function getPoolsuppliedBallot(address val)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return poolInfos[val].suppliedBallots;\r\n    }\r\n\r\n    function getPoolaccRewardPerShare(address val)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return poolInfos[val].accRewardPerShare;\r\n    }\r\n\r\n    function getPoolvoterNumber(address val) external view returns (uint256) {\r\n        return poolInfos[val].voterNumber;\r\n    }\r\n\r\n    function getPoolelectedNumber(address val) external view returns (uint256) {\r\n        return poolInfos[val].electedNumber;\r\n    }\r\n\r\n    function getPoolenabled(address val) external view override returns (bool) {\r\n        return poolInfos[val].enabled;\r\n    }\r\n\r\n    function getPoolManager(address val) external view returns (address) {\r\n        return poolInfos[val].manager;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\ninterface IValidators {\r\n\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        address validator;   // Address of validator.\r\n        address manager; \r\n        uint256 selfBallots;      // The validator's Margin in ballots\r\n        uint256 selfBallotsRewardsDebt;  // The validator's reward debt corresponding to selfBallots \r\n        uint256 feeShares;   // The commission rate in 1/10000 \r\n        uint256 pendingFee;  // The pending commission fee of the validator \r\n        uint256 feeDebt;     // The validators's commission fee debt, i.e, commission fees already withdrawn \r\n        uint256 lastRewardBlock;   // Last block number that the validator is rewarded\r\n        uint256 feeSettLockingEndTime;  // feeShares can not be changed before feeSettLockingEndTime \r\n        uint256 suppliedBallots; // Total ballots voted to this validator \r\n        uint256 accRewardPerShare; // Accumulated egcs per share, times 1e12.\r\n        uint256 voterNumber; // The number of votes of the validator \r\n        uint256 electedNumber; // The number of times the validator is rewarded.\r\n        bool enabled;    \r\n    }\r\n\r\n    // The detailed information of a validator \r\n    struct Description {\r\n        string website;\r\n        string email;\r\n        string details;\r\n    }\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How many ballot tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt.\r\n    }\r\n\r\n\r\n    // Info of each pool.\r\n    struct VotingData {\r\n        address validator;          //  The address of the validator \r\n        uint256 validatorBallot;    //  The total ballots of the validator \r\n        uint256 feeShares;          //  The commission rate of the validator in 1/10000\r\n        uint256 ballot;             //  The user's ballots in this validator \r\n        uint256 pendingReward;          // The user's pending reward \r\n        uint256 revokingBallot;         // The user's revoking ballots \r\n        uint256 revokeLockingEndTime;   // The user can withdraw KSCs corresponding to revokingBallot after revokeLockingEndTime\r\n    }\r\n\r\n    // The Revoking info of a user's ballots\r\n    struct RevokingInfo {\r\n        uint256 amount; // The amount of ballots that user is revoking \r\n        uint256 lockingEndTime; // The user can withdraw his/her revoking ballots after lockingEndTime\r\n    }\r\n\r\n    enum Operation {Distributed, UpdatedValidators}\r\n\r\n    function punish(address validator, bool remove) external; \r\n\r\n\r\n  \r\n    // @dev This can only be called by the miner from the KCC node. \r\n    function distributeBlockReward() external payable;\r\n    \r\n    function updateActiveValidatorSet(address[] calldata newSet)  external;\r\n\r\n    function getTopValidators()  external view returns (address[] memory); \r\n\r\n    function isActiveValidator(address val) external view returns (bool);\r\n\r\n    function getActiveValidators() external view returns (address[] memory);\r\n\r\n    function getPoolenabled(address val) external view returns (bool);\r\n\r\n}\r\n\r\n"
    },
    "contracts/interfaces/IPunish.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\ninterface IPunish {\r\n    function punish(address _val) external;\r\n}\r\n"
    },
    "contracts/interfaces/IProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\ninterface IProposal {\r\n\r\n    function isProposalPassed(address val, bytes32 id) external view returns(bool);\r\n\r\n}"
    },
    "contracts/interfaces/IReservePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\ninterface IReservePool {\r\n    function withdrawBlockReward() external returns (uint256);\r\n}\r\n"
    },
    "contracts/library/SortedList.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\nimport \"../interfaces/IValidators.sol\";\r\n\r\nlibrary SortedLinkedList {\r\n    struct List {\r\n        address head;\r\n        address tail;\r\n        uint256 length;\r\n        mapping(address => address) prev;\r\n        mapping(address => address) next;\r\n    }\r\n\r\n    function improveRanking(\r\n     List storage _list, \r\n     mapping(address=> IValidators.PoolInfo) storage poolInfos, \r\n     address _value)\r\n    internal {\r\n        //insert new\r\n        if (_list.length == 0) {\r\n            _list.head = _value;\r\n            _list.tail = _value;\r\n            _list.length++;\r\n            return;\r\n        }\r\n\r\n        //already first\r\n        if (_list.head == _value) {\r\n            return;\r\n        }\r\n\r\n        address _prev = _list.prev[_value];\r\n        // not in list\r\n        if (_prev == address(0)) {\r\n            //insert new\r\n            _list.length++;\r\n\r\n            if (poolInfos[ _value].suppliedBallots <= poolInfos[_list.tail].suppliedBallots) {\r\n                _list.prev[_value] = _list.tail;\r\n                _list.next[_list.tail] = _value;\r\n                _list.tail = _value;\r\n\r\n                return;\r\n            }\r\n\r\n            _prev = _list.tail;\r\n        } else {\r\n            if (poolInfos[ _value].suppliedBallots <= poolInfos[ _prev].suppliedBallots) {\r\n                return;\r\n            }\r\n\r\n            //remove from list\r\n            _list.next[_prev] = _list.next[_value];\r\n            if (_value == _list.tail) {\r\n                _list.tail = _prev;\r\n            } else {\r\n                _list.prev[_list.next[_value]] = _list.prev[_value];\r\n            }\r\n        }\r\n\r\n        while (_prev != address(0) && poolInfos[ _value].suppliedBallots > poolInfos[ _prev].suppliedBallots) {\r\n            _prev = _list.prev[_prev];\r\n        }\r\n\r\n        if (_prev == address(0)) {\r\n            _list.next[_value] = _list.head;\r\n            _list.prev[_list.head] = _value;\r\n            _list.prev[_value] = address(0);\r\n            _list.head = _value;\r\n        } else {\r\n            _list.next[_value] = _list.next[_prev];\r\n            _list.prev[_list.next[_prev]] = _value;\r\n            _list.next[_prev] = _value;\r\n            _list.prev[_value] = _prev;\r\n        }\r\n    }\r\n\r\n\r\n    function lowerRanking(\r\n     List storage _list,\r\n     mapping(address=> IValidators.PoolInfo) storage poolInfos,\r\n     address _value)\r\n    internal {\r\n        address _next = _list.next[_value];\r\n        if (_list.tail == _value || _next == address(0) || poolInfos[ _next].suppliedBallots <= poolInfos[ _value].suppliedBallots) {\r\n            return;\r\n        }\r\n\r\n        //remove it\r\n        _list.prev[_next] = _list.prev[_value];\r\n        if (_list.head == _value) {\r\n            _list.head = _next;\r\n        } else {\r\n            _list.next[_list.prev[_value]] = _next;\r\n        }\r\n\r\n        while (_next != address(0) && poolInfos[ _next].suppliedBallots > poolInfos[ _value].suppliedBallots) {\r\n            _next = _list.next[_next];\r\n        }\r\n\r\n        if (_next == address(0)) {\r\n            _list.prev[_value] = _list.tail;\r\n            _list.next[_value] = address(0);\r\n\r\n            _list.next[_list.tail] = _value;\r\n            _list.tail = _value;\r\n        } else {\r\n            _list.next[_list.prev[_next]] = _value;\r\n            _list.prev[_value] = _list.prev[_next];\r\n            _list.next[_value] = _next;\r\n            _list.prev[_next] = _value;\r\n        }\r\n    }\r\n\r\n\r\n    function removeRanking(List storage _list, address _value)\r\n    internal {\r\n        if (_list.head != _value && _list.prev[_value] == address(0)) {\r\n            //not in list\r\n            return;\r\n        }\r\n\r\n        if (_list.tail == _value) {\r\n            _list.tail = _list.prev[_value];\r\n        }\r\n\r\n        if (_list.head == _value) {\r\n            _list.head = _list.next[_value];\r\n        }\r\n\r\n        address _next = _list.next[_value];\r\n        if (_next != address(0)) {\r\n            _list.prev[_next] = _list.prev[_value];\r\n        }\r\n        address _prev = _list.prev[_value];\r\n        if (_prev != address(0)) {\r\n            _list.next[_prev] = _list.next[_value];\r\n        }\r\n\r\n        _list.prev[_value] = address(0);\r\n        _list.next[_value] = address(0);\r\n        _list.length--;\r\n    }\r\n}\r\n"
    },
    "contracts/library/SafeSend.sol": {
      "content": "\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nabstract contract SafeSend {\r\n\tfunction _sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success,) = recipient.call{value : amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}"
    },
    "contracts/test/ReservePoolMockForValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"../library/SafeSend.sol\";\r\n\r\ncontract ReservePoolMockForValidators is SafeSend {\r\n\r\n    uint256 public blockReward; \r\n\r\n    function withdrawBlockReward() external returns (uint256){\r\n        _sendValue(payable(msg.sender),blockReward);\r\n        return blockReward;\r\n    }\r\n\r\n    // solhint-disable no-empty-blocks\r\n    receive() external payable{}\r\n\r\n    function setBlockReward(uint256 r) public{\r\n        blockReward = r;\r\n    }\r\n}"
    },
    "contracts/test/MultiCallDistributeBlockReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"../interfaces/IValidators.sol\";\r\n\r\ncontract CallDistributeBlockRewardMultipleTimes {\r\n\r\n\r\n    IValidators public validators;\r\n\r\n    constructor(address _validators) public{\r\n        validators = IValidators(_validators);\r\n    }\r\n\r\n    function distributeBlockRewardMulti(uint256 times) external{\r\n        for(uint i = 0; i< times; i++){\r\n            validators.distributeBlockReward();\r\n        }\r\n    }\r\n}"
    },
    "contracts/Punish.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"./Params.sol\";\r\nimport \"./interfaces/IValidators.sol\";\r\nimport \"./Admin.sol\";\r\n\r\ncontract Punish is Params, Admin {\r\n    uint256 public punishThreshold;\r\n    uint256 public removeThreshold;\r\n    uint256 public decreaseRate;\r\n\r\n    struct PunishRecord {\r\n        uint256 missedBlocksCounter;\r\n        uint256 index;\r\n        bool exist;\r\n    }\r\n\r\n    mapping(address => PunishRecord) internal _punishRecords;\r\n    address[] public punishValidators;\r\n\r\n    mapping(uint256 => bool) internal _punished;\r\n    mapping(uint256 => bool) internal _decreased;\r\n\r\n    event LogDecreaseMissedBlocksCounter();\r\n    event LogPunishValidator(address indexed val, uint256 time);\r\n\r\n    modifier onlyNotPunished() {\r\n        require(!_punished[block.number], \"Already _punished\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyNotDecreased() {\r\n        require(!_decreased[block.number], \"Already _decreased\");\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _validatorsContract,\r\n        address _punishContract,\r\n        address _proposalContract,\r\n        address _reservePool,\r\n        address _admin,\r\n        uint256 _epoch\r\n    ) external initializer {\r\n        _Admin_Init(_admin);\r\n        _setAddressesAndEpoch(\r\n            _validatorsContract,\r\n            _punishContract,\r\n            _proposalContract,\r\n            _reservePool,\r\n            _epoch\r\n        );\r\n        punishThreshold = 24;\r\n        removeThreshold = 48;\r\n        decreaseRate = 24;\r\n    }\r\n\r\n    function punish(address _val) external onlyMiner onlyNotPunished {\r\n        _punished[block.number] = true;\r\n\r\n        // Don't punish the validator again who was jailed\r\n        if (!VALIDATOR_CONTRACT.getPoolenabled(_val)) {\r\n            return;\r\n        }\r\n        if (!_punishRecords[_val].exist) {\r\n            _punishRecords[_val].index = punishValidators.length;\r\n            punishValidators.push(_val);\r\n            _punishRecords[_val].exist = true;\r\n        }\r\n        _punishRecords[_val].missedBlocksCounter++;\r\n\r\n        if (_punishRecords[_val].missedBlocksCounter % removeThreshold == 0) {\r\n            VALIDATOR_CONTRACT.punish(_val, true);\r\n            // reset validator's missed blocks counter\r\n            _punishRecords[_val].missedBlocksCounter = 0;\r\n            _cleanPunishRecord(_val);\r\n        } else if (\r\n            _punishRecords[_val].missedBlocksCounter % punishThreshold == 0\r\n        ) {\r\n            VALIDATOR_CONTRACT.punish(_val, false);\r\n        }\r\n\r\n        emit LogPunishValidator(_val, block.timestamp); // solhint-disable-line not-rely-on-time\r\n    }\r\n\r\n    function decreaseMissedBlocksCounter()\r\n        external\r\n        onlyMiner\r\n        onlyNotDecreased\r\n        onlyBlockEpoch\r\n    {\r\n        _decreased[block.number] = true;\r\n        if (punishValidators.length == 0) {\r\n            return;\r\n        }\r\n\r\n        for (uint256 i = 0; i < punishValidators.length; i++) {\r\n            if (\r\n                _punishRecords[punishValidators[i]].missedBlocksCounter >\r\n                removeThreshold / decreaseRate\r\n            ) {\r\n                _punishRecords[punishValidators[i]].missedBlocksCounter =\r\n                    _punishRecords[punishValidators[i]].missedBlocksCounter -\r\n                    removeThreshold /\r\n                    decreaseRate;\r\n            } else {\r\n                _punishRecords[punishValidators[i]].missedBlocksCounter = 0;\r\n            }\r\n        }\r\n\r\n        emit LogDecreaseMissedBlocksCounter();\r\n    }\r\n\r\n    // clean validator's punish record if one vote in\r\n    function _cleanPunishRecord(address _val) internal {\r\n        if (_punishRecords[_val].missedBlocksCounter != 0) {\r\n            _punishRecords[_val].missedBlocksCounter = 0;\r\n        }\r\n\r\n        // remove it out of array if exist\r\n        if (_punishRecords[_val].exist && punishValidators.length > 0) {\r\n            if (_punishRecords[_val].index != punishValidators.length - 1) {\r\n                address _tail = punishValidators[punishValidators.length - 1];\r\n                punishValidators[_punishRecords[_val].index] = _tail;\r\n\r\n                _punishRecords[_tail].index = _punishRecords[_val].index;\r\n            }\r\n            punishValidators.pop();\r\n            _punishRecords[_val].index = 0;\r\n            _punishRecords[_val].exist = false;\r\n        }\r\n    }\r\n\r\n    function getPunishValidatorsLen() public view returns (uint256) {\r\n        return punishValidators.length;\r\n    }\r\n\r\n    function getPunishRecord(address val) public view returns (uint256) {\r\n        return _punishRecords[val].missedBlocksCounter;\r\n    }\r\n}\r\n"
    },
    "contracts/Params.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"./interfaces/IValidators.sol\";\r\nimport \"./interfaces/IPunish.sol\";\r\nimport \"./interfaces/IProposal.sol\";\r\nimport \"./interfaces/IReservePool.sol\";\r\nimport \"@openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\";\r\n \r\ncontract Params is Initializable {\r\n\r\n    // System contracts addresses \r\n    IValidators public  VALIDATOR_CONTRACT; // solhint-disable var-name-mixedcase\r\n    IPunish public  PUBLISH_CONTRACT;       // solhint-disable var-name-mixedcase\r\n    IProposal public  PROPOSAL_CONTRACT;    // solhint-disable var-name-mixedcase\r\n    IReservePool public RESERVEPOOL_CONTRACT; // solhint-disable var-name-mixedcase\r\n    uint256 public EPOCH; // solhint-disable var-name-mixedcase\r\n\r\n    // System params\r\n    uint16 public constant MAX_VALIDATORS = 29;\r\n\r\n    function _onlyMiner() private view {\r\n        require(msg.sender == block.coinbase, \"Miner only\");\r\n    }\r\n    \r\n\r\n    modifier onlyMiner() {\r\n        _onlyMiner();\r\n        _;\r\n    }\r\n    function _onlyPunishContract() private view {\r\n        require(msg.sender == address(PUBLISH_CONTRACT), \"Punish contract only\");\r\n    }\r\n\r\n    modifier onlyPunishContract() {\r\n        _onlyPunishContract();\r\n        _;\r\n    }\r\n    \r\n\r\n    modifier onlyBlockEpoch {\r\n        require(block.number % EPOCH == 0, \"Block epoch only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValidatorsContract() {\r\n        require(msg.sender == address(VALIDATOR_CONTRACT), \"Validators contract only\");\r\n        _;\r\n\r\n    }\r\n\r\n    function _setAddressesAndEpoch(\r\n            address _validatorsContract,\r\n            address _punishContract,\r\n            address _proposalContract,\r\n            address _reservePool,\r\n            uint256 epoch\r\n    ) internal initializer{\r\n        VALIDATOR_CONTRACT = IValidators(payable(_validatorsContract));\r\n        PUBLISH_CONTRACT = IPunish(payable(_punishContract));\r\n        PROPOSAL_CONTRACT = IProposal(payable(_proposalContract));\r\n        RESERVEPOOL_CONTRACT = IReservePool(payable(_reservePool));\r\n        EPOCH = epoch;\r\n    }\r\n\r\n}\r\n"
    },
    "contracts/ReservePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"./Params.sol\";\r\nimport \"./interfaces/IReservePool.sol\";\r\nimport \"./Admin.sol\";\r\n\r\ncontract ReservePool is Params, Admin, IReservePool {\r\n    enum State {\r\n        DISABLED,\r\n        ENABLED\r\n    }\r\n\r\n    // The Block Reward for each block\r\n    uint256 public blockRewardAmount;\r\n    // The maximum block reward amount\r\n    uint256 public constant MAX_BLOCK_REWARD_AMOUNT = 100 ether;\r\n    // Has block reward already withdrawn from this block?\r\n    mapping(uint256 => uint256) internal _rewardWithdrawnRecords;\r\n\r\n    // Events\r\n\r\n    // Withdraw from reservePool\r\n    event Withdraw(address indexed actor, uint256 amount);\r\n\r\n    // Deposit to reservePool\r\n    event Deposit(address indexed actor, uint256 amount);\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    // The state of the reservePool:\r\n    //  - DISABLED: no egc can be withrawn from the reservePool\r\n    //  - ENABLED: egc can be withdrawn from the reservePool\r\n    State public state;\r\n\r\n    function initialize(\r\n        address _admin,\r\n        address _validatorsContract,\r\n        address _punishContract,\r\n        address _proposalContract,\r\n        address _reservePool,\r\n        uint256 _epoch\r\n    ) external initializer {\r\n        _Admin_Init(_admin);\r\n        _setAddressesAndEpoch(\r\n            _validatorsContract,\r\n            _punishContract,\r\n            _proposalContract,\r\n            _reservePool,\r\n            _epoch\r\n        );\r\n        state = State.ENABLED; // enabled after initialized\r\n    }\r\n\r\n    // Withdraw Block Reward from ReservePool\r\n    // This method can only be called once per block and can only be called by ValidatorsContract.\r\n    //\r\n    //  @returns:  the amount withdrawn from ReservePool and received by msg.sender\r\n    //\r\n    function withdrawBlockReward()\r\n        external\r\n        override\r\n        onlyValidatorsContract\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            _rewardWithdrawnRecords[block.number] == 0,\r\n            \"multiple withdrawals in a single block\"\r\n        );\r\n\r\n        if (state != State.ENABLED) {\r\n            // reservePool not enabled\r\n            return 0;\r\n        }\r\n\r\n        uint256 amount;\r\n\r\n        if (address(this).balance > blockRewardAmount) {\r\n            amount = blockRewardAmount;\r\n        } else {\r\n            amount = address(this).balance;\r\n        }\r\n\r\n        _rewardWithdrawnRecords[block.number] = 1;\r\n\r\n        // solhint-disable avoid-low-level-calls\r\n        (bool success, ) = msg.sender.call{value: amount}(new bytes(0));\r\n        require(success, \"ReservePool: egc transfer failed\");\r\n\r\n        emit Withdraw(msg.sender, amount);\r\n\r\n        return amount;\r\n    }\r\n\r\n    // Set the state of reservePool:\r\n    //   @params newState\r\n    function setState(State newState) external onlyAdmin {\r\n        require(\r\n            newState == State.DISABLED || newState == State.ENABLED,\r\n            \"invalid state\"\r\n        );\r\n        state = newState;\r\n    }\r\n\r\n    // Set the new block reward amount\r\n    function setBlockRewardAmount(uint256 amount) external onlyAdmin {\r\n        require(\r\n            amount < MAX_BLOCK_REWARD_AMOUNT,\r\n            \"amount is greater than maximum\"\r\n        );\r\n        blockRewardAmount = amount;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n}\r\n"
    },
    "contracts/test/ValidatorMockForReservePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"../interfaces/IReservePool.sol\";\r\n\r\ncontract ValidatorMockForReservePool {\r\n\r\n    IReservePool public reservePool; \r\n    uint256   public lastWithdrawAmount; \r\n\r\n\r\n    function setReservePool(address pool) public{\r\n        reservePool = IReservePool(pool);\r\n    }\r\n\r\n    function withdrawBlockReward() external returns(uint256) {\r\n        lastWithdrawAmount = reservePool.withdrawBlockReward();\r\n        return lastWithdrawAmount;\r\n    }\r\n\r\n    // solhint-disable no-empty-blocks\r\n    receive() external payable{}\r\n\r\n}"
    },
    "contracts/Proposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"./Params.sol\";\r\nimport \"./interfaces/IValidators.sol\";\r\nimport \"./Admin.sol\";\r\n\r\ncontract Proposal is Params, Admin, IProposal {\r\n    // How long a proposal will exist\r\n    uint256 public proposalLastingPeriod;\r\n\r\n    uint256 public proposalEffectivePeriod;\r\n\r\n    // record\r\n    // mapping(address => bool) public pass;\r\n    mapping(bytes32 => bool) public pass;\r\n\r\n    struct ProposalInfo {\r\n        // who propose this proposal\r\n        address proposer;\r\n        // propose who to be a validator\r\n        address dst;\r\n        // optional detail info of proposal\r\n        string details;\r\n        // time create proposal\r\n        uint256 createTime;\r\n        //\r\n        // vote info\r\n        //\r\n        // number agree this proposal\r\n        uint16 agree;\r\n        // number reject this proposal\r\n        uint16 reject;\r\n        // means you can get proposal of current vote.\r\n        bool resultExist;\r\n    }\r\n\r\n    struct VoteInfo {\r\n        address voter;\r\n        uint256 voteTime;\r\n        bool auth;\r\n    }\r\n\r\n    //  candiate address => the id of the latest proposal for the candidate\r\n    mapping(address => bytes32) public latest;\r\n    //  proposal id => proposalInfo\r\n    mapping(bytes32 => ProposalInfo) public proposals;\r\n    mapping(address => mapping(bytes32 => VoteInfo)) public votes;\r\n\r\n    event LogCreateProposal(\r\n        bytes32 indexed id,\r\n        address indexed proposer,\r\n        address indexed dst,\r\n        uint256 time\r\n    );\r\n    event LogVote(\r\n        bytes32 indexed id,\r\n        address indexed voter,\r\n        bool auth,\r\n        uint256 time\r\n    );\r\n    event LogPassProposal(\r\n        bytes32 indexed id,\r\n        address indexed dst,\r\n        uint256 time\r\n    );\r\n    event LogRejectProposal(\r\n        bytes32 indexed id,\r\n        address indexed dst,\r\n        uint256 time\r\n    );\r\n    event LogSetUnpassed(address indexed val, bytes32 id, uint256 time);\r\n\r\n    modifier onlyValidator() {\r\n        // FIXME: is candidate?\r\n        require(\r\n            VALIDATOR_CONTRACT.isActiveValidator(msg.sender),\r\n            \"Validator only\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function initialize(\r\n        address _admin,\r\n        address _validatorsContract,\r\n        address _punishContract,\r\n        address _proposalContract,\r\n        address _reservePool,\r\n        uint256 _epoch\r\n    ) external initializer {\r\n        _Admin_Init(_admin);\r\n        _setAddressesAndEpoch(\r\n            _validatorsContract,\r\n            _punishContract,\r\n            _proposalContract,\r\n            _reservePool,\r\n            _epoch\r\n        );\r\n        proposalLastingPeriod = 7 days;\r\n        proposalEffectivePeriod = 30 days;\r\n    }\r\n\r\n    function createProposal(address dst, string calldata details)\r\n        external\r\n        onlyAdmin\r\n        returns (bytes32)\r\n    {\r\n        // generate proposal id\r\n        bytes32 id = keccak256(\r\n            abi.encodePacked(msg.sender, dst, details, block.timestamp)\r\n        );\r\n        require(bytes(details).length <= 3000, \"Details too long\");\r\n        require(proposals[id].createTime == 0, \"Proposal already exists\");\r\n\r\n        ProposalInfo memory proposal;\r\n        proposal.proposer = msg.sender;\r\n        proposal.dst = dst;\r\n        proposal.details = details;\r\n        proposal.createTime = block.timestamp;\r\n\r\n        proposals[id] = proposal;\r\n        latest[dst] = id;\r\n\r\n        emit LogCreateProposal(id, msg.sender, dst, block.timestamp);\r\n        return id;\r\n    }\r\n\r\n    function isProposalPassed(address val, bytes32 id)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        require(latest[val] == id, \"not matched\");\r\n        if (\r\n            block.timestamp >\r\n            proposals[id].createTime +\r\n                proposalLastingPeriod +\r\n                proposalEffectivePeriod\r\n        ) {\r\n            return false;\r\n        } else {\r\n            return pass[id];\r\n        }\r\n    }\r\n\r\n    function getLatestProposalId(address val) external view returns (bytes32) {\r\n        return latest[val];\r\n    }\r\n\r\n    function voteProposal(bytes32 id, bool auth)\r\n        external\r\n        onlyValidator\r\n        returns (bool)\r\n    {\r\n        require(proposals[id].createTime != 0, \"Proposal not exist\");\r\n        require(\r\n            votes[msg.sender][id].voteTime == 0,\r\n            \"You can't vote for a proposal twice\"\r\n        );\r\n        require(\r\n            block.timestamp < proposals[id].createTime + proposalLastingPeriod,\r\n            \"Proposal expired\"\r\n        );\r\n\r\n        votes[msg.sender][id].voteTime = block.timestamp;\r\n        votes[msg.sender][id].voter = msg.sender;\r\n        votes[msg.sender][id].auth = auth;\r\n        emit LogVote(id, msg.sender, auth, block.timestamp);\r\n\r\n        // update dst status if proposal is passed\r\n        if (auth) {\r\n            proposals[id].agree = proposals[id].agree + 1;\r\n        } else {\r\n            proposals[id].reject = proposals[id].reject + 1;\r\n        }\r\n\r\n        if (pass[id] || proposals[id].resultExist) {\r\n            // do nothing if dst already passed or rejected.\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            proposals[id].agree >=\r\n            VALIDATOR_CONTRACT.getActiveValidators().length / 2 + 1\r\n        ) {\r\n            pass[id] = true;\r\n            proposals[id].resultExist = true;\r\n\r\n            emit LogPassProposal(id, proposals[id].dst, block.timestamp);\r\n\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            proposals[id].reject >=\r\n            VALIDATOR_CONTRACT.getActiveValidators().length / 2 + 1\r\n        ) {\r\n            pass[id] = false;\r\n            proposals[id].resultExist = true;\r\n            emit LogRejectProposal(id, proposals[id].dst, block.timestamp);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function setUnpassed(address val, bytes32 id)\r\n        external\r\n        onlyValidatorsContract\r\n        returns (bool)\r\n    {\r\n        // set validator unpass\r\n        pass[id] = false;\r\n\r\n        emit LogSetUnpassed(val, id, block.timestamp);\r\n        return true;\r\n    }\r\n}\r\n"
    },
    "contracts/test/MultiCallPunish.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nimport \"../interfaces/IPunish.sol\";\r\n\r\ncontract CallPunishMultipleTimes {\r\n\r\n\r\n    IPunish public punish;\r\n\r\n    constructor(address _punish) public{\r\n        punish = IPunish(_punish);\r\n    }\r\n\r\n    function punishMultipleTimes(address _val, uint256 times) external{\r\n        for(uint i = 0; i< times; i++){\r\n            punish.punish(_val);\r\n        }\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}